{"ast":null,"code":"import _extends from\"@babel/runtime/helpers/extends\";import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import _regeneratorRuntime from\"@babel/runtime/regenerator\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";import _createClass from\"@babel/runtime/helpers/createClass\";import _inherits from\"@babel/runtime/helpers/inherits\";import _objectWithoutProperties from\"@babel/runtime/helpers/objectWithoutProperties\";import React from'react';import Linking from\"react-native-web/dist/exports/Linking\";import Platform from\"react-native-web/dist/exports/Platform\";import BackHandler from\"react-native-web/dist/exports/BackHandler\";import{NavigationActions,pathUtils,getNavigation,NavigationProvider}from'@react-navigation/core';import invariant from\"./utils/invariant\";import docsUrl from\"./utils/docsUrl\";var urlToPathAndParams=pathUtils.urlToPathAndParams;function isStateful(props){return!props.navigation;}function validateProps(props){if(props.persistenceKey){console.warn('You passed persistenceKey prop to a navigator. '+'The persistenceKey prop was replaced by a more flexible persistence mechanism, '+'please see the navigation state persistence docs for more information. '+'Passing the persistenceKey prop is a no-op.');}if(isStateful(props)){return;}var navigation=props.navigation,screenProps=props.screenProps,persistNavigationState=props.persistNavigationState,loadNavigationState=props.loadNavigationState,containerProps=_objectWithoutProperties(props,[\"navigation\",\"screenProps\",\"persistNavigationState\",\"loadNavigationState\"]);var keys=Object.keys(containerProps);if(keys.length!==0){throw new Error('This navigator has both navigation and container props, so it is '+(\"unclear if it should own its own state. Remove props: \\\"\"+keys.join(', ')+\"\\\" \")+'if the navigator should get its state from the navigation prop. If the '+'navigator should maintain its own state, do not pass a navigation prop.');}invariant(persistNavigationState===undefined&&loadNavigationState===undefined||typeof persistNavigationState==='function'&&typeof loadNavigationState==='function','both persistNavigationState and loadNavigationState must either be undefined, or be functions');}var _statefulContainerCount=0;export function _TESTING_ONLY_reset_container_count(){_statefulContainerCount=0;}var _reactNavigationIsHydratingState=false;export default function createNavigationContainer(Component){var NavigationContainer=function(_React$Component){_inherits(NavigationContainer,_React$Component);_createClass(NavigationContainer,null,[{key:\"getDerivedStateFromProps\",value:function getDerivedStateFromProps(nextProps){validateProps(nextProps);return null;}}]);function NavigationContainer(props){var _this;_classCallCheck(this,NavigationContainer);_this=_possibleConstructorReturn(this,_getPrototypeOf(NavigationContainer).call(this,props));_this.subs=null;_this._actionEventSubscribers=new Set();_this._handleOpenURL=function(_ref){var url=_ref.url;var _this$props=_this.props,enableURLHandling=_this$props.enableURLHandling,uriPrefix=_this$props.uriPrefix;if(enableURLHandling===false){return;}var parsedUrl=urlToPathAndParams(url,uriPrefix);if(parsedUrl){var path=parsedUrl.path,params=parsedUrl.params;var action=Component.router.getActionForPathAndParams(path,params);if(action){_this.dispatch(action);}}};_this._persistNavigationState=function _callee(nav){var persistNavigationState;return _regeneratorRuntime.async(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:persistNavigationState=_this.props.persistNavigationState;if(!persistNavigationState){_context.next=10;break;}_context.prev=2;_context.next=5;return _regeneratorRuntime.awrap(persistNavigationState(nav));case 5:_context.next=10;break;case 7:_context.prev=7;_context.t0=_context[\"catch\"](2);console.warn('Uncaught exception while calling persistNavigationState()! You should handle exceptions thrown from persistNavigationState(), ignoring them may result in undefined behavior.');case 10:case\"end\":return _context.stop();}}},null,null,[[2,7]]);};_this.dispatch=function(action){if(_this.props.navigation){return _this.props.navigation.dispatch(action);}_this._navState=_this._navState||_this.state.nav;var lastNavState=_this._navState;invariant(lastNavState,'should be set in constructor if stateful');var reducedState=Component.router.getStateForAction(action,lastNavState);var navState=reducedState===null?lastNavState:reducedState;var dispatchActionEvents=function dispatchActionEvents(){_this._actionEventSubscribers.forEach(function(subscriber){return subscriber({type:'action',action:action,state:navState,lastState:lastNavState});});};if(reducedState===null){dispatchActionEvents();return true;}if(navState!==lastNavState){_this._navState=navState;_this.setState({nav:navState},function(){_this._onNavigationStateChange(lastNavState,navState,action);dispatchActionEvents();_this._persistNavigationState(navState);});return true;}dispatchActionEvents();return false;};_this._getScreenProps=function(){return _this.props.screenProps;};validateProps(props);_this._initialAction=NavigationActions.init();if(_this._isStateful()&&BackHandler&&typeof BackHandler.addEventListener==='function'){_this.subs=BackHandler.addEventListener('hardwareBackPress',function(){if(!_this._isMounted){_this.subs&&_this.subs.remove();}else{return _this.dispatch(NavigationActions.back());}});}_this.state={nav:_this._isStateful()&&!props.loadNavigationState?Component.router.getStateForAction(_this._initialAction):null};return _this;}_createClass(NavigationContainer,[{key:\"_renderLoading\",value:function _renderLoading(){return this.props.renderLoadingExperimental?this.props.renderLoadingExperimental():null;}},{key:\"_isStateful\",value:function _isStateful(){return isStateful(this.props);}},{key:\"_validateProps\",value:function _validateProps(props){if(this._isStateful()){return;}var navigation=props.navigation,screenProps=props.screenProps,containerProps=_objectWithoutProperties(props,[\"navigation\",\"screenProps\"]);var keys=Object.keys(containerProps);if(keys.length!==0){throw new Error('This navigator has both navigation and container props, so it is '+(\"unclear if it should own its own state. Remove props: \\\"\"+keys.join(', ')+\"\\\" \")+'if the navigator should get its state from the navigation prop. If the '+'navigator should maintain its own state, do not pass a navigation prop.');}}},{key:\"_onNavigationStateChange\",value:function _onNavigationStateChange(prevNav,nav,action){if(typeof this.props.onNavigationStateChange==='undefined'&&this._isStateful()&&!!process.env.REACT_NAV_LOGGING){if(console.group){console.group('Navigation Dispatch: ');console.log('Action: ',action);console.log('New State: ',nav);console.log('Last State: ',prevNav);console.groupEnd();}else{console.log('Navigation Dispatch: ',{action:action,newState:nav,lastState:prevNav});}return;}if(typeof this.props.onNavigationStateChange==='function'){this.props.onNavigationStateChange(prevNav,nav,action);}}},{key:\"componentDidUpdate\",value:function componentDidUpdate(){if(this._navState===this.state.nav){this._navState=null;}}},{key:\"componentDidMount\",value:function componentDidMount(){var _this2=this;var parsedUrl,userProvidedStartupState,_await$this$getStartu,action,startupState,_parsedUrl,path,params,urlAction,dispatchActions;return _regeneratorRuntime.async(function componentDidMount$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:this._isMounted=true;if(this._isStateful()){_context2.next=3;break;}return _context2.abrupt(\"return\");case 3:if(__DEV__&&!this.props.detached){if(_statefulContainerCount>0){if(Platform.OS==='ios'){console.warn(\"You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: \"+docsUrl('common-mistakes.html#explicitly-rendering-more-than-one-navigator'));}}}_statefulContainerCount++;Linking.addEventListener('url',this._handleOpenURL);parsedUrl=null;userProvidedStartupState=null;if(!(this.props.enableURLHandling!==false)){_context2.next=14;break;}_context2.next=11;return _regeneratorRuntime.awrap(this.getStartupParams());case 11:_await$this$getStartu=_context2.sent;parsedUrl=_await$this$getStartu.parsedUrl;userProvidedStartupState=_await$this$getStartu.userProvidedStartupState;case 14:action=this._initialAction;startupState=this.state.nav;if(!startupState&&!userProvidedStartupState){!!process.env.REACT_NAV_LOGGING&&console.log('Init new Navigation State');startupState=Component.router.getStateForAction(action);}if(userProvidedStartupState){startupState=userProvidedStartupState;_reactNavigationIsHydratingState=true;}if(parsedUrl){_parsedUrl=parsedUrl,path=_parsedUrl.path,params=_parsedUrl.params;urlAction=Component.router.getActionForPathAndParams(path,params);if(urlAction){!!process.env.REACT_NAV_LOGGING&&console.log('Applying Navigation Action for Initial URL:',parsedUrl);action=urlAction;startupState=Component.router.getStateForAction(urlAction,startupState);}}dispatchActions=function dispatchActions(){return _this2._actionEventSubscribers.forEach(function(subscriber){return subscriber({type:'action',action:action,state:_this2.state.nav,lastState:null});});};if(!(startupState===this.state.nav)){_context2.next=23;break;}dispatchActions();return _context2.abrupt(\"return\");case 23:this.setState({nav:startupState},function(){_reactNavigationIsHydratingState=false;dispatchActions();});case 24:case\"end\":return _context2.stop();}}},null,this);}},{key:\"getStartupParams\",value:function getStartupParams(){var _this$props2,uriPrefix,loadNavigationState,url,loadedNavState,_await$Promise$all,_await$Promise$all2;return _regeneratorRuntime.async(function getStartupParams$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_this$props2=this.props,uriPrefix=_this$props2.uriPrefix,loadNavigationState=_this$props2.loadNavigationState;_context3.prev=1;_context3.next=4;return _regeneratorRuntime.awrap(Promise.all([Linking.getInitialURL(),loadNavigationState&&loadNavigationState()]));case 4:_await$Promise$all=_context3.sent;_await$Promise$all2=_slicedToArray(_await$Promise$all,2);url=_await$Promise$all2[0];loadedNavState=_await$Promise$all2[1];_context3.next=12;break;case 10:_context3.prev=10;_context3.t0=_context3[\"catch\"](1);case 12:return _context3.abrupt(\"return\",{parsedUrl:url&&urlToPathAndParams(url,uriPrefix),userProvidedStartupState:loadedNavState});case 13:case\"end\":return _context3.stop();}}},null,this,[[1,10]]);}},{key:\"componentDidCatch\",value:function componentDidCatch(e){if(_reactNavigationIsHydratingState){_reactNavigationIsHydratingState=false;console.warn('Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state...');this.dispatch(NavigationActions.init());}else{throw e;}}},{key:\"componentWillUnmount\",value:function componentWillUnmount(){this._isMounted=false;Linking.removeEventListener('url',this._handleOpenURL);this.subs&&this.subs.remove();if(this._isStateful()){_statefulContainerCount--;}}},{key:\"render\",value:function render(){var _this3=this;var navigation=this.props.navigation;if(this._isStateful()){var navState=this.state.nav;if(!navState){return this._renderLoading();}if(!this._navigation||this._navigation.state!==navState){this._navigation=getNavigation(Component.router,navState,this.dispatch,this._actionEventSubscribers,this._getScreenProps,function(){return _this3._navigation;});}navigation=this._navigation;}invariant(navigation,'failed to get navigation');return React.createElement(NavigationProvider,{value:navigation},React.createElement(Component,_extends({},this.props,{navigation:navigation})));}}]);return NavigationContainer;}(React.Component);NavigationContainer.router=Component.router;NavigationContainer.navigationOptions=null;return NavigationContainer;}","map":{"version":3,"sources":["/Users/user/Documents/codecanyon-B1UUUVLW-harrier-react-native-ecommerce-ui-kit-template/eCommerce2/node_modules/@react-navigation/native/dist/createAppContainer.js"],"names":["React","NavigationActions","pathUtils","getNavigation","NavigationProvider","invariant","docsUrl","urlToPathAndParams","isStateful","props","navigation","validateProps","persistenceKey","console","warn","screenProps","persistNavigationState","loadNavigationState","containerProps","keys","Object","length","Error","join","undefined","_statefulContainerCount","_TESTING_ONLY_reset_container_count","_reactNavigationIsHydratingState","createNavigationContainer","Component","NavigationContainer","nextProps","subs","_actionEventSubscribers","Set","_handleOpenURL","url","enableURLHandling","uriPrefix","parsedUrl","path","params","action","router","getActionForPathAndParams","dispatch","_persistNavigationState","nav","_navState","state","lastNavState","reducedState","getStateForAction","navState","dispatchActionEvents","forEach","subscriber","type","lastState","setState","_onNavigationStateChange","_getScreenProps","_initialAction","init","_isStateful","BackHandler","addEventListener","_isMounted","remove","back","renderLoadingExperimental","prevNav","onNavigationStateChange","process","env","REACT_NAV_LOGGING","group","log","groupEnd","newState","__DEV__","detached","Platform","OS","Linking","userProvidedStartupState","getStartupParams","startupState","urlAction","dispatchActions","Promise","all","getInitialURL","loadedNavState","e","removeEventListener","_renderLoading","_navigation","navigationOptions"],"mappings":"0lBAAA,MAAOA,CAAAA,KAAP,KAAkB,OAAlB,C,2LAEA,OAASC,iBAAT,CAA4BC,SAA5B,CAAuCC,aAAvC,CAAsDC,kBAAtD,KAAgF,wBAAhF,CACA,MAAOC,CAAAA,SAAP,yBACA,MAAOC,CAAAA,OAAP,uB,GAEQC,CAAAA,kB,CAAuBL,S,CAAvBK,kB,CAER,QAASC,CAAAA,UAAT,CAAoBC,KAApB,CAA2B,CACzB,MAAO,CAACA,KAAK,CAACC,UAAd,CACD,CAED,QAASC,CAAAA,aAAT,CAAuBF,KAAvB,CAA8B,CAC5B,GAAIA,KAAK,CAACG,cAAV,CAA0B,CACxBC,OAAO,CAACC,IAAR,CAAa,kDAAoD,iFAApD,CAAwI,yEAAxI,CAAoN,6CAAjO,EACD,CACD,GAAIN,UAAU,CAACC,KAAD,CAAd,CAAuB,CACrB,OACD,CAN2B,GAS1BC,CAAAA,UAT0B,CAcxBD,KAdwB,CAS1BC,UAT0B,CAU1BK,WAV0B,CAcxBN,KAdwB,CAU1BM,WAV0B,CAW1BC,sBAX0B,CAcxBP,KAdwB,CAW1BO,sBAX0B,CAY1BC,mBAZ0B,CAcxBR,KAdwB,CAY1BQ,mBAZ0B,CAavBC,cAbuB,0BAcxBT,KAdwB,8EAiB5B,GAAMU,CAAAA,IAAI,CAAGC,MAAM,CAACD,IAAP,CAAYD,cAAZ,CAAb,CAEA,GAAIC,IAAI,CAACE,MAAL,GAAgB,CAApB,CAAuB,CACrB,KAAM,IAAIC,CAAAA,KAAJ,CAAU,gIAAgIH,IAAI,CAACI,IAAL,CAAU,IAAV,CAAhI,QAAsJ,yEAAtJ,CAAkO,yEAA5O,CAAN,CACD,CACDlB,SAAS,CAACW,sBAAsB,GAAKQ,SAA3B,EAAwCP,mBAAmB,GAAKO,SAAhE,EAA6E,MAAOR,CAAAA,sBAAP,GAAkC,UAAlC,EAAgD,MAAOC,CAAAA,mBAAP,GAA+B,UAA7J,CAAyK,+FAAzK,CAAT,CACD,CAMD,GAAIQ,CAAAA,uBAAuB,CAAG,CAA9B,CACA,MAAO,SAASC,CAAAA,mCAAT,EAA+C,CACpDD,uBAAuB,CAAG,CAA1B,CACD,CAID,GAAIE,CAAAA,gCAAgC,CAAG,KAAvC,CAYA,cAAe,SAASC,CAAAA,yBAAT,CAAmCC,SAAnC,CAA8C,IACrDC,CAAAA,mBADqD,2LAOzBC,SAPyB,CAOd,CACzCpB,aAAa,CAACoB,SAAD,CAAb,CACA,MAAO,KAAP,CACD,CAVwD,IAczD,6BAAYtB,KAAZ,CAAmB,qDACjB,qFAAMA,KAAN,GADiB,MAZnBuB,IAYmB,CAZZ,IAYY,OAFnBC,uBAEmB,CAFO,GAAIC,CAAAA,GAAJ,EAEP,OAgDnBC,cAhDmB,CAgDF,cAAa,IAAVC,CAAAA,GAAU,MAAVA,GAAU,iBACa,MAAK3B,KADlB,CACpB4B,iBADoB,aACpBA,iBADoB,CACDC,SADC,aACDA,SADC,CAE5B,GAAID,iBAAiB,GAAK,KAA1B,CAAiC,CAC/B,OACD,CACD,GAAME,CAAAA,SAAS,CAAGhC,kBAAkB,CAAC6B,GAAD,CAAME,SAAN,CAApC,CACA,GAAIC,SAAJ,CAAe,IACLC,CAAAA,IADK,CACYD,SADZ,CACLC,IADK,CACCC,MADD,CACYF,SADZ,CACCE,MADD,CAEb,GAAMC,CAAAA,MAAM,CAAGb,SAAS,CAACc,MAAV,CAAiBC,yBAAjB,CAA2CJ,IAA3C,CAAiDC,MAAjD,CAAf,CACA,GAAIC,MAAJ,CAAY,CACV,MAAKG,QAAL,CAAcH,MAAd,EACD,CACF,CACF,CA7DkB,OA+LnBI,uBA/LmB,CA+LO,iBAAMC,GAAN,8IAChB/B,sBADgB,CACW,MAAKP,KADhB,CAChBO,sBADgB,KAEpBA,sBAFoB,2FAIdA,sBAAsB,CAAC+B,GAAD,CAJR,wFAMpBlC,OAAO,CAACC,IAAR,CAAa,+KAAb,EANoB,iEA/LP,OAsNnB+B,QAtNmB,CAsNR,SAAAH,MAAM,CAAI,CACnB,GAAI,MAAKjC,KAAL,CAAWC,UAAf,CAA2B,CACzB,MAAO,OAAKD,KAAL,CAAWC,UAAX,CAAsBmC,QAAtB,CAA+BH,MAA/B,CAAP,CACD,CAGD,MAAKM,SAAL,CAAiB,MAAKA,SAAL,EAAkB,MAAKC,KAAL,CAAWF,GAA9C,CACA,GAAMG,CAAAA,YAAY,CAAG,MAAKF,SAA1B,CACA3C,SAAS,CAAC6C,YAAD,CAAe,0CAAf,CAAT,CACA,GAAMC,CAAAA,YAAY,CAAGtB,SAAS,CAACc,MAAV,CAAiBS,iBAAjB,CAAmCV,MAAnC,CAA2CQ,YAA3C,CAArB,CACA,GAAMG,CAAAA,QAAQ,CAAGF,YAAY,GAAK,IAAjB,CAAwBD,YAAxB,CAAuCC,YAAxD,CAEA,GAAMG,CAAAA,oBAAoB,CAAG,QAAvBA,CAAAA,oBAAuB,EAAM,CACjC,MAAKrB,uBAAL,CAA6BsB,OAA7B,CAAqC,SAAAC,UAAU,QAAIA,CAAAA,UAAU,CAAC,CAC5DC,IAAI,CAAE,QADsD,CAE5Df,MAAM,CAANA,MAF4D,CAG5DO,KAAK,CAAEI,QAHqD,CAI5DK,SAAS,CAAER,YAJiD,CAAD,CAAd,EAA/C,EAMD,CAPD,CASA,GAAIC,YAAY,GAAK,IAArB,CAA2B,CAGzBG,oBAAoB,GACpB,MAAO,KAAP,CACD,CAED,GAAID,QAAQ,GAAKH,YAAjB,CAA+B,CAE7B,MAAKF,SAAL,CAAiBK,QAAjB,CACA,MAAKM,QAAL,CAAc,CAAEZ,GAAG,CAAEM,QAAP,CAAd,CAAiC,UAAM,CACrC,MAAKO,wBAAL,CAA8BV,YAA9B,CAA4CG,QAA5C,CAAsDX,MAAtD,EACAY,oBAAoB,GACpB,MAAKR,uBAAL,CAA6BO,QAA7B,EACD,CAJD,EAKA,MAAO,KAAP,CACD,CAEDC,oBAAoB,GACpB,MAAO,MAAP,CACD,CA/PkB,OAiQnBO,eAjQmB,CAiQD,iBAAM,OAAKpD,KAAL,CAAWM,WAAjB,EAjQC,CAGjBJ,aAAa,CAACF,KAAD,CAAb,CAEA,MAAKqD,cAAL,CAAsB7D,iBAAiB,CAAC8D,IAAlB,EAAtB,CAEA,GAAI,MAAKC,WAAL,IAAsBC,WAAtB,EAAqC,MAAOA,CAAAA,WAAW,CAACC,gBAAnB,GAAwC,UAAjF,CAA6F,CAC3F,MAAKlC,IAAL,CAAYiC,WAAW,CAACC,gBAAZ,CAA6B,mBAA7B,CAAkD,UAAM,CAClE,GAAI,CAAC,MAAKC,UAAV,CAAsB,CACpB,MAAKnC,IAAL,EAAa,MAAKA,IAAL,CAAUoC,MAAV,EAAb,CACD,CAFD,IAEO,CAIL,MAAO,OAAKvB,QAAL,CAAc5C,iBAAiB,CAACoE,IAAlB,EAAd,CAAP,CACD,CACF,CATW,CAAZ,CAUD,CAED,MAAKpB,KAAL,CAAa,CACXF,GAAG,CAAE,MAAKiB,WAAL,IAAsB,CAACvD,KAAK,CAACQ,mBAA7B,CAAmDY,SAAS,CAACc,MAAV,CAAiBS,iBAAjB,CAAmC,MAAKU,cAAxC,CAAnD,CAA6G,IADvG,CAAb,CApBiB,aAuBlB,CArCwD,uFAuCxC,CACf,MAAO,MAAKrD,KAAL,CAAW6D,yBAAX,CAAuC,KAAK7D,KAAL,CAAW6D,yBAAX,EAAvC,CAAgF,IAAvF,CACD,CAzCwD,iDA2C3C,CACZ,MAAO9D,CAAAA,UAAU,CAAC,KAAKC,KAAN,CAAjB,CACD,CA7CwD,sDA+C1CA,KA/C0C,CA+CnC,CACpB,GAAI,KAAKuD,WAAL,EAAJ,CAAwB,CACtB,OACD,CAHmB,GAMZtD,CAAAA,UANY,CAMmCD,KANnC,CAMZC,UANY,CAMAK,WANA,CAMmCN,KANnC,CAMAM,WANA,CAMgBG,cANhB,0BAMmCT,KANnC,+BAQpB,GAAMU,CAAAA,IAAI,CAAGC,MAAM,CAACD,IAAP,CAAYD,cAAZ,CAAb,CAEA,GAAIC,IAAI,CAACE,MAAL,GAAgB,CAApB,CAAuB,CACrB,KAAM,IAAIC,CAAAA,KAAJ,CAAU,gIAAgIH,IAAI,CAACI,IAAL,CAAU,IAAV,CAAhI,QAAsJ,yEAAtJ,CAAkO,yEAA5O,CAAN,CACD,CACF,CA5DwD,0EA6EhCgD,OA7EgC,CA6EvBxB,GA7EuB,CA6ElBL,MA7EkB,CA6EV,CAC7C,GAAI,MAAO,MAAKjC,KAAL,CAAW+D,uBAAlB,GAA8C,WAA9C,EAA6D,KAAKR,WAAL,EAA7D,EAAmF,CAAC,CAACS,OAAO,CAACC,GAAR,CAAYC,iBAArG,CAAwH,CACtH,GAAI9D,OAAO,CAAC+D,KAAZ,CAAmB,CACjB/D,OAAO,CAAC+D,KAAR,CAAc,uBAAd,EACA/D,OAAO,CAACgE,GAAR,CAAY,UAAZ,CAAwBnC,MAAxB,EACA7B,OAAO,CAACgE,GAAR,CAAY,aAAZ,CAA2B9B,GAA3B,EACAlC,OAAO,CAACgE,GAAR,CAAY,cAAZ,CAA4BN,OAA5B,EACA1D,OAAO,CAACiE,QAAR,GACD,CAND,IAMO,CACLjE,OAAO,CAACgE,GAAR,CAAY,uBAAZ,CAAqC,CACnCnC,MAAM,CAANA,MADmC,CAEnCqC,QAAQ,CAAEhC,GAFyB,CAGnCW,SAAS,CAAEa,OAHwB,CAArC,EAKD,CACD,OACD,CAED,GAAI,MAAO,MAAK9D,KAAL,CAAW+D,uBAAlB,GAA8C,UAAlD,CAA8D,CAC5D,KAAK/D,KAAL,CAAW+D,uBAAX,CAAmCD,OAAnC,CAA4CxB,GAA5C,CAAiDL,MAAjD,EACD,CACF,CAlGwD,+DAoGpC,CAEnB,GAAI,KAAKM,SAAL,GAAmB,KAAKC,KAAL,CAAWF,GAAlC,CAAuC,CACrC,KAAKC,SAAL,CAAiB,IAAjB,CACD,CACF,CAzGwD,8UA4GvD,KAAKmB,UAAL,CAAkB,IAAlB,CA5GuD,GA6GlD,KAAKH,WAAL,EA7GkD,mEAiHvD,GAAIgB,OAAO,EAAI,CAAC,KAAKvE,KAAL,CAAWwE,QAA3B,CAAqC,CACnC,GAAIxD,uBAAuB,CAAG,CAA9B,CAAiC,CAG/B,GAAIyD,QAAQ,CAACC,EAAT,GAAgB,KAApB,CAA2B,CACzBtE,OAAO,CAACC,IAAR,+JAA2KR,OAAO,CAAC,mEAAD,CAAlL,EACD,CACF,CACF,CACDmB,uBAAuB,GACvB2D,OAAO,CAAClB,gBAAR,CAAyB,KAAzB,CAAgC,KAAK/B,cAArC,EAGII,SA9HmD,CA8HvC,IA9HuC,CA+HnD8C,wBA/HmD,CA+HxB,IA/HwB,MAgInD,KAAK5E,KAAL,CAAW4B,iBAAX,GAAiC,KAhIkB,+EAoI3C,KAAKiD,gBAAL,EApI2C,+CAkInD/C,SAlImD,uBAkInDA,SAlImD,CAmInD8C,wBAnImD,uBAmInDA,wBAnImD,SA0InD3C,MA1ImD,CA0I1C,KAAKoB,cA1IqC,CA2InDyB,YA3ImD,CA2IpC,KAAKtC,KAAL,CAAWF,GA3IyB,CA4IvD,GAAI,CAACwC,YAAD,EAAiB,CAACF,wBAAtB,CAAgD,CAC9C,CAAC,CAACZ,OAAO,CAACC,GAAR,CAAYC,iBAAd,EAAmC9D,OAAO,CAACgE,GAAR,CAAY,2BAAZ,CAAnC,CACAU,YAAY,CAAG1D,SAAS,CAACc,MAAV,CAAiBS,iBAAjB,CAAmCV,MAAnC,CAAf,CACD,CAGD,GAAI2C,wBAAJ,CAA8B,CAC5BE,YAAY,CAAGF,wBAAf,CACA1D,gCAAgC,CAAG,IAAnC,CACD,CAGD,GAAIY,SAAJ,CAAe,YACYA,SADZ,CACLC,IADK,YACLA,IADK,CACCC,MADD,YACCA,MADD,CAEP+C,SAFO,CAEK3D,SAAS,CAACc,MAAV,CAAiBC,yBAAjB,CAA2CJ,IAA3C,CAAiDC,MAAjD,CAFL,CAGb,GAAI+C,SAAJ,CAAe,CACb,CAAC,CAACf,OAAO,CAACC,GAAR,CAAYC,iBAAd,EAAmC9D,OAAO,CAACgE,GAAR,CAAY,6CAAZ,CAA2DtC,SAA3D,CAAnC,CACAG,MAAM,CAAG8C,SAAT,CACAD,YAAY,CAAG1D,SAAS,CAACc,MAAV,CAAiBS,iBAAjB,CAAmCoC,SAAnC,CAA8CD,YAA9C,CAAf,CACD,CACF,CAEKE,eAlKiD,CAkK/B,QAAlBA,CAAAA,eAAkB,SAAM,CAAA,MAAI,CAACxD,uBAAL,CAA6BsB,OAA7B,CAAqC,SAAAC,UAAU,QAAIA,CAAAA,UAAU,CAAC,CAC1FC,IAAI,CAAE,QADoF,CAE1Ff,MAAM,CAANA,MAF0F,CAG1FO,KAAK,CAAE,MAAI,CAACA,KAAL,CAAWF,GAHwE,CAI1FW,SAAS,CAAE,IAJ+E,CAAD,CAAd,EAA/C,CAAN,EAlK+B,MAyKnD6B,YAAY,GAAK,KAAKtC,KAAL,CAAWF,GAzKuB,4BA0KrD0C,eAAe,GA1KsC,0CA+KvD,KAAK9B,QAAL,CAAc,CAAEZ,GAAG,CAAEwC,YAAP,CAAd,CAAqC,UAAM,CACzC5D,gCAAgC,CAAG,KAAnC,CACA8D,eAAe,GAChB,CAHD,EA/KuD,yWAsLZ,KAAKhF,KAtLO,CAsL/C6B,SAtL+C,cAsL/CA,SAtL+C,CAsLpCrB,mBAtLoC,cAsLpCA,mBAtLoC,oEAyLvByE,OAAO,CAACC,GAAR,CAAY,CAACP,OAAO,CAACQ,aAAR,EAAD,CAA0B3E,mBAAmB,EAAIA,mBAAmB,EAApE,CAAZ,CAzLuB,oGAyLpDmB,GAzLoD,wBAyL/CyD,cAzL+C,sJA6LhD,CACLtD,SAAS,CAAEH,GAAG,EAAI7B,kBAAkB,CAAC6B,GAAD,CAAME,SAAN,CAD/B,CAEL+C,wBAAwB,CAAEQ,cAFrB,CA7LgD,iIAmMvCC,CAnMuC,CAmMpC,CACnB,GAAInE,gCAAJ,CAAsC,CACpCA,gCAAgC,CAAG,KAAnC,CACAd,OAAO,CAACC,IAAR,CAAa,gIAAb,EACA,KAAK+B,QAAL,CAAc5C,iBAAiB,CAAC8D,IAAlB,EAAd,EACD,CAJD,IAIO,CACL,KAAM+B,CAAAA,CAAN,CACD,CACF,CA3MwD,mEAwNlC,CACrB,KAAK3B,UAAL,CAAkB,KAAlB,CACAiB,OAAO,CAACW,mBAAR,CAA4B,KAA5B,CAAmC,KAAK5D,cAAxC,EACA,KAAKH,IAAL,EAAa,KAAKA,IAAL,CAAUoC,MAAV,EAAb,CAEA,GAAI,KAAKJ,WAAL,EAAJ,CAAwB,CACtBvC,uBAAuB,GACxB,CACF,CAhOwD,uCAiRhD,iBACP,GAAIf,CAAAA,UAAU,CAAG,KAAKD,KAAL,CAAWC,UAA5B,CACA,GAAI,KAAKsD,WAAL,EAAJ,CAAwB,CACtB,GAAMX,CAAAA,QAAQ,CAAG,KAAKJ,KAAL,CAAWF,GAA5B,CACA,GAAI,CAACM,QAAL,CAAe,CACb,MAAO,MAAK2C,cAAL,EAAP,CACD,CACD,GAAI,CAAC,KAAKC,WAAN,EAAqB,KAAKA,WAAL,CAAiBhD,KAAjB,GAA2BI,QAApD,CAA8D,CAC5D,KAAK4C,WAAL,CAAmB9F,aAAa,CAAC0B,SAAS,CAACc,MAAX,CAAmBU,QAAnB,CAA6B,KAAKR,QAAlC,CAA4C,KAAKZ,uBAAjD,CAA0E,KAAK4B,eAA/E,CAAgG,iBAAM,CAAA,MAAI,CAACoC,WAAX,EAAhG,CAAhC,CACD,CACDvF,UAAU,CAAG,KAAKuF,WAAlB,CACD,CACD5F,SAAS,CAACK,UAAD,CAAa,0BAAb,CAAT,CACA,MAAO,qBAAC,kBAAD,EAAoB,KAAK,CAAEA,UAA3B,EACH,oBAAC,SAAD,aAAe,KAAKD,KAApB,EAA2B,UAAU,CAAEC,UAAvC,GADG,CAAP,CAGD,CAjSwD,iCACzBV,KAAK,CAAC6B,SADmB,EACrDC,mBADqD,CAIlDa,MAJkD,CAIzCd,SAAS,CAACc,MAJ+B,CACrDb,mBADqD,CAKlDoE,iBALkD,CAK9B,IAL8B,CAoS3D,MAAOpE,CAAAA,mBAAP,CACD","sourcesContent":["import React from 'react';\nimport { Linking, Platform, BackHandler } from 'react-native';\nimport { NavigationActions, pathUtils, getNavigation, NavigationProvider } from '@react-navigation/core';\nimport invariant from './utils/invariant';\nimport docsUrl from './utils/docsUrl';\n\nconst { urlToPathAndParams } = pathUtils;\n\nfunction isStateful(props) {\n  return !props.navigation;\n}\n\nfunction validateProps(props) {\n  if (props.persistenceKey) {\n    console.warn('You passed persistenceKey prop to a navigator. ' + 'The persistenceKey prop was replaced by a more flexible persistence mechanism, ' + 'please see the navigation state persistence docs for more information. ' + 'Passing the persistenceKey prop is a no-op.');\n  }\n  if (isStateful(props)) {\n    return;\n  }\n  /* eslint-disable no-unused-vars */\n  const {\n    navigation,\n    screenProps,\n    persistNavigationState,\n    loadNavigationState,\n    ...containerProps\n  } = props;\n  /* eslint-enable no-unused-vars */\n\n  const keys = Object.keys(containerProps);\n\n  if (keys.length !== 0) {\n    throw new Error('This navigator has both navigation and container props, so it is ' + `unclear if it should own its own state. Remove props: \"${keys.join(', ')}\" ` + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n  }\n  invariant(persistNavigationState === undefined && loadNavigationState === undefined || typeof persistNavigationState === 'function' && typeof loadNavigationState === 'function', 'both persistNavigationState and loadNavigationState must either be undefined, or be functions');\n}\n\n// Track the number of stateful container instances. Warn if >0 and not using the\n// detached prop to explicitly acknowledge the behavior. We should deprecated implicit\n// stateful navigation containers in a future release and require a provider style pattern\n// instead in order to eliminate confusion entirely.\nlet _statefulContainerCount = 0;\nexport function _TESTING_ONLY_reset_container_count() {\n  _statefulContainerCount = 0;\n}\n\n// We keep a global flag to catch errors during the state persistence hydrating scenario.\n// The innermost navigator who catches the error will dispatch a new init action.\nlet _reactNavigationIsHydratingState = false;\n// Unfortunate to use global state here, but it seems necessesary for the time\n// being. There seems to be some problems with cascading componentDidCatch\n// handlers. Ideally the inner non-stateful navigator catches the error and\n// re-throws it, to be caught by the top-level stateful navigator.\n\n/**\n * Create an HOC that injects the navigation and manages the navigation state\n * in case it's not passed from above.\n * This allows to use e.g. the StackNavigator and TabNavigator as root-level\n * components.\n */\nexport default function createNavigationContainer(Component) {\n  class NavigationContainer extends React.Component {\n    subs = null;\n\n    static router = Component.router;\n    static navigationOptions = null;\n\n    static getDerivedStateFromProps(nextProps) {\n      validateProps(nextProps);\n      return null;\n    }\n\n    _actionEventSubscribers = new Set();\n\n    constructor(props) {\n      super(props);\n\n      validateProps(props);\n\n      this._initialAction = NavigationActions.init();\n\n      if (this._isStateful() && BackHandler && typeof BackHandler.addEventListener === 'function') {\n        this.subs = BackHandler.addEventListener('hardwareBackPress', () => {\n          if (!this._isMounted) {\n            this.subs && this.subs.remove();\n          } else {\n            // dispatch returns true if the action results in a state change,\n            // and false otherwise. This maps well to what BackHandler expects\n            // from a callback -- true if handled, false if not handled\n            return this.dispatch(NavigationActions.back());\n          }\n        });\n      }\n\n      this.state = {\n        nav: this._isStateful() && !props.loadNavigationState ? Component.router.getStateForAction(this._initialAction) : null\n      };\n    }\n\n    _renderLoading() {\n      return this.props.renderLoadingExperimental ? this.props.renderLoadingExperimental() : null;\n    }\n\n    _isStateful() {\n      return isStateful(this.props);\n    }\n\n    _validateProps(props) {\n      if (this._isStateful()) {\n        return;\n      }\n\n      // eslint-disable-next-line no-unused-vars\n      const { navigation, screenProps, ...containerProps } = props;\n\n      const keys = Object.keys(containerProps);\n\n      if (keys.length !== 0) {\n        throw new Error('This navigator has both navigation and container props, so it is ' + `unclear if it should own its own state. Remove props: \"${keys.join(', ')}\" ` + 'if the navigator should get its state from the navigation prop. If the ' + 'navigator should maintain its own state, do not pass a navigation prop.');\n      }\n    }\n\n    _handleOpenURL = ({ url }) => {\n      const { enableURLHandling, uriPrefix } = this.props;\n      if (enableURLHandling === false) {\n        return;\n      }\n      const parsedUrl = urlToPathAndParams(url, uriPrefix);\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const action = Component.router.getActionForPathAndParams(path, params);\n        if (action) {\n          this.dispatch(action);\n        }\n      }\n    };\n\n    _onNavigationStateChange(prevNav, nav, action) {\n      if (typeof this.props.onNavigationStateChange === 'undefined' && this._isStateful() && !!process.env.REACT_NAV_LOGGING) {\n        if (console.group) {\n          console.group('Navigation Dispatch: ');\n          console.log('Action: ', action);\n          console.log('New State: ', nav);\n          console.log('Last State: ', prevNav);\n          console.groupEnd();\n        } else {\n          console.log('Navigation Dispatch: ', {\n            action,\n            newState: nav,\n            lastState: prevNav\n          });\n        }\n        return;\n      }\n\n      if (typeof this.props.onNavigationStateChange === 'function') {\n        this.props.onNavigationStateChange(prevNav, nav, action);\n      }\n    }\n\n    componentDidUpdate() {\n      // Clear cached _navState every tick\n      if (this._navState === this.state.nav) {\n        this._navState = null;\n      }\n    }\n\n    async componentDidMount() {\n      this._isMounted = true;\n      if (!this._isStateful()) {\n        return;\n      }\n\n      if (__DEV__ && !this.props.detached) {\n        if (_statefulContainerCount > 0) {\n          // Temporarily only show this on iOS due to this issue:\n          // https://github.com/react-navigation/react-navigation/issues/4196#issuecomment-390827829\n          if (Platform.OS === 'ios') {\n            console.warn(`You should only render one navigator explicitly in your app, and other navigators should be rendered by including them in that navigator. Full details at: ${docsUrl('common-mistakes.html#explicitly-rendering-more-than-one-navigator')}`);\n          }\n        }\n      }\n      _statefulContainerCount++;\n      Linking.addEventListener('url', this._handleOpenURL);\n\n      // Pull out anything that can impact state\n      let parsedUrl = null;\n      let userProvidedStartupState = null;\n      if (this.props.enableURLHandling !== false) {\n        ({\n          parsedUrl,\n          userProvidedStartupState\n        } = await this.getStartupParams());\n      }\n\n      // Initialize state. This must be done *after* any async code\n      // so we don't end up with a different value for this.state.nav\n      // due to changes while async function was resolving\n      let action = this._initialAction;\n      let startupState = this.state.nav;\n      if (!startupState && !userProvidedStartupState) {\n        !!process.env.REACT_NAV_LOGGING && console.log('Init new Navigation State');\n        startupState = Component.router.getStateForAction(action);\n      }\n\n      // Pull user-provided persisted state\n      if (userProvidedStartupState) {\n        startupState = userProvidedStartupState;\n        _reactNavigationIsHydratingState = true;\n      }\n\n      // Pull state out of URL\n      if (parsedUrl) {\n        const { path, params } = parsedUrl;\n        const urlAction = Component.router.getActionForPathAndParams(path, params);\n        if (urlAction) {\n          !!process.env.REACT_NAV_LOGGING && console.log('Applying Navigation Action for Initial URL:', parsedUrl);\n          action = urlAction;\n          startupState = Component.router.getStateForAction(urlAction, startupState);\n        }\n      }\n\n      const dispatchActions = () => this._actionEventSubscribers.forEach(subscriber => subscriber({\n        type: 'action',\n        action,\n        state: this.state.nav,\n        lastState: null\n      }));\n\n      if (startupState === this.state.nav) {\n        dispatchActions();\n        return;\n      }\n\n      // eslint-disable-next-line react/no-did-mount-set-state\n      this.setState({ nav: startupState }, () => {\n        _reactNavigationIsHydratingState = false;\n        dispatchActions();\n      });\n    }\n\n    async getStartupParams() {\n      const { uriPrefix, loadNavigationState } = this.props;\n      let url, loadedNavState;\n      try {\n        [url, loadedNavState] = await Promise.all([Linking.getInitialURL(), loadNavigationState && loadNavigationState()]);\n      } catch (err) {\n        // ignore\n      }\n      return {\n        parsedUrl: url && urlToPathAndParams(url, uriPrefix),\n        userProvidedStartupState: loadedNavState\n      };\n    }\n\n    componentDidCatch(e) {\n      if (_reactNavigationIsHydratingState) {\n        _reactNavigationIsHydratingState = false;\n        console.warn('Uncaught exception while starting app from persisted navigation state! Trying to render again with a fresh navigation state...');\n        this.dispatch(NavigationActions.init());\n      } else {\n        throw e;\n      }\n    }\n\n    _persistNavigationState = async nav => {\n      const { persistNavigationState } = this.props;\n      if (persistNavigationState) {\n        try {\n          await persistNavigationState(nav);\n        } catch (err) {\n          console.warn('Uncaught exception while calling persistNavigationState()! You should handle exceptions thrown from persistNavigationState(), ignoring them may result in undefined behavior.');\n        }\n      }\n    };\n\n    componentWillUnmount() {\n      this._isMounted = false;\n      Linking.removeEventListener('url', this._handleOpenURL);\n      this.subs && this.subs.remove();\n\n      if (this._isStateful()) {\n        _statefulContainerCount--;\n      }\n    }\n\n    // Per-tick temporary storage for state.nav\n\n    dispatch = action => {\n      if (this.props.navigation) {\n        return this.props.navigation.dispatch(action);\n      }\n\n      // navState will have the most up-to-date value, because setState sometimes behaves asyncronously\n      this._navState = this._navState || this.state.nav;\n      const lastNavState = this._navState;\n      invariant(lastNavState, 'should be set in constructor if stateful');\n      const reducedState = Component.router.getStateForAction(action, lastNavState);\n      const navState = reducedState === null ? lastNavState : reducedState;\n\n      const dispatchActionEvents = () => {\n        this._actionEventSubscribers.forEach(subscriber => subscriber({\n          type: 'action',\n          action,\n          state: navState,\n          lastState: lastNavState\n        }));\n      };\n\n      if (reducedState === null) {\n        // The router will return null when action has been handled and the state hasn't changed.\n        // dispatch returns true when something has been handled.\n        dispatchActionEvents();\n        return true;\n      }\n\n      if (navState !== lastNavState) {\n        // Cache updates to state.nav during the tick to ensure that subsequent calls will not discard this change\n        this._navState = navState;\n        this.setState({ nav: navState }, () => {\n          this._onNavigationStateChange(lastNavState, navState, action);\n          dispatchActionEvents();\n          this._persistNavigationState(navState);\n        });\n        return true;\n      }\n\n      dispatchActionEvents();\n      return false;\n    };\n\n    _getScreenProps = () => this.props.screenProps;\n\n    render() {\n      let navigation = this.props.navigation;\n      if (this._isStateful()) {\n        const navState = this.state.nav;\n        if (!navState) {\n          return this._renderLoading();\n        }\n        if (!this._navigation || this._navigation.state !== navState) {\n          this._navigation = getNavigation(Component.router, navState, this.dispatch, this._actionEventSubscribers, this._getScreenProps, () => this._navigation);\n        }\n        navigation = this._navigation;\n      }\n      invariant(navigation, 'failed to get navigation');\n      return <NavigationProvider value={navigation}>\n          <Component {...this.props} navigation={navigation} />\n        </NavigationProvider>;\n    }\n  }\n\n  return NavigationContainer;\n}"]},"metadata":{},"sourceType":"module"}