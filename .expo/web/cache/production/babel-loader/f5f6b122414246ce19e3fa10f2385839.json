{"ast":null,"code":"import _objectSpread from\"@babel/runtime/helpers/objectSpread\";import shallowEqual from\"../utils/shallowEqual\";var SCENE_KEY_PREFIX='scene_';function compareKey(one,two){var delta=one.length-two.length;if(delta>0){return 1;}if(delta<0){return-1;}return one>two?1:-1;}function compareScenes(one,two){if(one.index>two.index){return 1;}if(one.index<two.index){return-1;}return compareKey(one.key,two.key);}function areScenesShallowEqual(one,two){return one.key===two.key&&one.index===two.index&&one.isStale===two.isStale&&one.isActive===two.isActive&&areRoutesShallowEqual(one.route,two.route);}function areRoutesShallowEqual(one,two){if(!one||!two){return one===two;}if(one.key!==two.key){return false;}return shallowEqual(one,two);}export default function ScenesReducer(scenes,nextState,prevState,descriptors){scenes.forEach(function(scene){var route=scene.route;if(descriptors&&descriptors[route.key]){scene.descriptor=descriptors[route.key];}});if(prevState===nextState){return scenes;}var prevScenes=new Map();var freshScenes=new Map();var staleScenes=new Map();scenes.forEach(function(scene){var key=scene.key;if(scene.isStale){staleScenes.set(key,scene);}prevScenes.set(key,scene);});var nextKeys=new Set();var nextRoutes=nextState.routes;if(nextRoutes.length>nextState.index+1){console.warn('StackRouter provided invalid state, index should always be the top route');nextRoutes=nextState.routes.slice(0,nextState.index+1);}nextRoutes.forEach(function(route,index){var key=SCENE_KEY_PREFIX+route.key;var descriptor=descriptors&&descriptors[route.key];var scene={index:index,isActive:false,isStale:false,key:key,route:route,descriptor:descriptor};if(nextKeys.has(key)){throw new Error(\"navigation.state.routes[\"+index+\"].key \\\"\"+key+\"\\\" conflicts with \"+'another route!');}nextKeys.add(key);if(staleScenes.has(key)){staleScenes.delete(key);}freshScenes.set(key,scene);});if(prevState){var prevRoutes=prevState.routes;if(prevRoutes.length>prevState.index+1){console.warn('StackRouter provided invalid state, index should always be the top route');prevRoutes=prevRoutes.slice(0,prevState.index+1);}prevRoutes.forEach(function(route,index){var key=SCENE_KEY_PREFIX+route.key;if(freshScenes.has(key)){return;}var lastScene=scenes.find(function(scene){return scene.route.key===route.key;});var descriptor=lastScene?lastScene.descriptor:descriptors[route.key];if(descriptor){staleScenes.set(key,{index:index,isActive:false,isStale:true,key:key,route:route,descriptor:descriptor});}});}var nextScenes=[];var mergeScene=function mergeScene(nextScene){var key=nextScene.key;var prevScene=prevScenes.has(key)?prevScenes.get(key):null;if(prevScene&&areScenesShallowEqual(prevScene,nextScene)){nextScenes.push(prevScene);}else{nextScenes.push(nextScene);}};staleScenes.forEach(mergeScene);freshScenes.forEach(mergeScene);nextScenes.sort(compareScenes);var activeScenesCount=0;nextScenes.forEach(function(scene,ii){var isActive=!scene.isStale&&scene.index===nextState.index;if(isActive!==scene.isActive){nextScenes[ii]=_objectSpread({},scene,{isActive:isActive});}if(isActive){activeScenesCount++;}});if(activeScenesCount!==1){throw new Error(\"There should always be only one scene active, not \"+activeScenesCount+\".\");}if(nextScenes.length!==scenes.length){return nextScenes;}if(nextScenes.some(function(scene,index){return!areScenesShallowEqual(scenes[index],scene);})){return nextScenes;}return scenes;}","map":{"version":3,"sources":["ScenesReducer.tsx"],"names":["SCENE_KEY_PREFIX","delta","one","two","compareKey","areRoutesShallowEqual","shallowEqual","scenes","route","scene","descriptors","prevState","prevScenes","freshScenes","staleScenes","key","nextKeys","nextRoutes","nextState","console","descriptor","index","isActive","isStale","prevRoutes","lastScene","nextScenes","mergeScene","nextScene","prevScene","areScenesShallowEqual","activeScenesCount"],"mappings":"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","sourcesContent":["import shallowEqual from '../utils/shallowEqual';\nimport { Scene, Route, NavigationState, SceneDescriptor } from '../types';\n\nconst SCENE_KEY_PREFIX = 'scene_';\n\n/**\n * Helper function to compare route keys (e.g. \"9\", \"11\").\n */\nfunction compareKey(one: string, two: string) {\n  const delta = one.length - two.length;\n  if (delta > 0) {\n    return 1;\n  }\n  if (delta < 0) {\n    return -1;\n  }\n  return one > two ? 1 : -1;\n}\n\n/**\n * Helper function to sort scenes based on their index and view key.\n */\nfunction compareScenes(one: Scene, two: Scene) {\n  if (one.index > two.index) {\n    return 1;\n  }\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areScenesShallowEqual(one: Scene, two: Scene) {\n  return (\n    one.key === two.key &&\n    one.index === two.index &&\n    one.isStale === two.isStale &&\n    one.isActive === two.isActive &&\n    areRoutesShallowEqual(one.route, two.route)\n  );\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areRoutesShallowEqual(one: Route, two: Route) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(\n  scenes: Scene[],\n  nextState: NavigationState,\n  prevState: NavigationState | null,\n  descriptors: { [key: string]: SceneDescriptor }\n) {\n  // Always update the descriptors\n  // This is a workaround for https://github.com/react-navigation/react-navigation/issues/4271\n  // It will be resolved in a better way when we re-write Transitioner\n  scenes.forEach(scene => {\n    const { route } = scene;\n    if (descriptors && descriptors[route.key]) {\n      scene.descriptor = descriptors[route.key];\n    }\n  });\n\n  // Bail out early if we didn't update the state\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  const prevScenes = new Map();\n  const freshScenes = new Map();\n  const staleScenes = new Map();\n\n  // Populate stale scenes from previous scenes marked as stale.\n  scenes.forEach(scene => {\n    const { key } = scene;\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n    prevScenes.set(key, scene);\n  });\n\n  const nextKeys = new Set();\n  let nextRoutes = nextState.routes;\n  if (nextRoutes.length > nextState.index + 1) {\n    console.warn(\n      'StackRouter provided invalid state, index should always be the top route'\n    );\n    nextRoutes = nextState.routes.slice(0, nextState.index + 1);\n  }\n\n  nextRoutes.forEach((route, index) => {\n    const key = SCENE_KEY_PREFIX + route.key;\n\n    let descriptor = descriptors && descriptors[route.key];\n\n    const scene: Scene = {\n      index,\n      isActive: false,\n      isStale: false,\n      key,\n      route,\n      descriptor,\n    };\n\n    if (nextKeys.has(key)) {\n      throw new Error(\n        `navigation.state.routes[${index}].key \"${key}\" conflicts with ` +\n          'another route!'\n      );\n    }\n\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      // A previously `stale` scene is now part of the nextState, so we\n      // revive it by removing it from the stale scene map.\n      staleScenes.delete(key);\n    }\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    let prevRoutes = prevState.routes;\n    if (prevRoutes.length > prevState.index + 1) {\n      console.warn(\n        'StackRouter provided invalid state, index should always be the top route'\n      );\n      prevRoutes = prevRoutes.slice(0, prevState.index + 1);\n    }\n    // Look at the previous routes and classify any removed scenes as `stale`.\n    prevRoutes.forEach((route, index) => {\n      const key = SCENE_KEY_PREFIX + route.key;\n      if (freshScenes.has(key)) {\n        return;\n      }\n      const lastScene = scenes.find(scene => scene.route.key === route.key);\n\n      // We can get into a weird place where we have a queued transition and then clobber\n      // that transition without ever actually rendering the scene, in which case\n      // there is no lastScene. If the descriptor is not available on the lastScene\n      // or the descriptors prop then we just skip adding it to stale scenes and it's\n      // not ever rendered.\n      const descriptor = lastScene\n        ? lastScene.descriptor\n        : descriptors[route.key];\n\n      if (descriptor) {\n        staleScenes.set(key, {\n          index,\n          isActive: false,\n          isStale: true,\n          key,\n          route,\n          descriptor,\n        });\n      }\n    });\n  }\n\n  const nextScenes: Scene[] = [];\n\n  const mergeScene = (nextScene: Scene) => {\n    const { key } = nextScene;\n    const prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      // Reuse `prevScene` as `scene` so view can avoid unnecessary re-render.\n      // This assumes that the scene's navigation state is immutable.\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n\n  nextScenes.sort(compareScenes);\n\n  let activeScenesCount = 0;\n  nextScenes.forEach((scene, ii) => {\n    const isActive = !scene.isStale && scene.index === nextState.index;\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = {\n        ...scene,\n        isActive,\n      };\n    }\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n\n  if (activeScenesCount !== 1) {\n    throw new Error(\n      `There should always be only one scene active, not ${activeScenesCount}.`\n    );\n  }\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (\n    nextScenes.some(\n      (scene, index) => !areScenesShallowEqual(scenes[index], scene)\n    )\n  ) {\n    return nextScenes;\n  }\n\n  // scenes haven't changed.\n  return scenes;\n}\n"]},"metadata":{},"sourceType":"module"}