{"ast":null,"code":"import _ from\"lodash\";import customMerge from\"./customMerge\";function isStyleVariant(propertyName){return /^\\./.test(propertyName);}function isChildStyle(propertyName){return /(^[^\\.].*\\.)|^\\*$/.test(propertyName);}function splitStyle(style){return _.reduce(style,function(result,value,key){var styleSection=result.componentStyle;if(isStyleVariant(key)){styleSection=result.styleVariants;}else if(isChildStyle(key)){styleSection=result.childrenStyle;}styleSection[key]=value;return result;},{componentStyle:{},styleVariants:{},childrenStyle:{}});}export function resolveComponentStyle(componentName){var styleNames=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var themeStyle=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var parentStyle=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};var themeCache=arguments.length>4?arguments[4]:undefined;var mergedStyle=customMerge(themeStyle,parentStyle[componentName]);styleNames.forEach(function(sn,index){mergedStyle=customMerge(mergedStyle,themeStyle[\"\"+sn]);});styleNames.forEach(function(sn,index){mergedStyle=customMerge(mergedStyle,parentStyle[\"\"+componentName+sn]);});var resolvedStyle=customMerge(mergedStyle,parentStyle[componentName]);styleNames.forEach(function(sn,index){resolvedStyle=customMerge(resolvedStyle,mergedStyle[\"\"+sn]);});styleNames.forEach(function(sn,index){resolvedStyle=customMerge(resolvedStyle,parentStyle[\"\"+componentName+sn]);});return resolvedStyle;}","map":{"version":3,"sources":["/Users/yuvalbeiser/Downloads/codecanyon-B1UUUVLW-harrier-react-native-ecommerce-ui-kit-template/eCommerce2/node_modules/native-base-shoutem-theme/src/resolveComponentStyle.js"],"names":["_","customMerge","isStyleVariant","propertyName","test","isChildStyle","splitStyle","style","reduce","result","value","key","styleSection","componentStyle","styleVariants","childrenStyle","resolveComponentStyle","componentName","styleNames","themeStyle","parentStyle","themeCache","mergedStyle","forEach","sn","index","resolvedStyle"],"mappings":"AAAA,MAAOA,CAAAA,CAAP,KAAc,QAAd,CACA,MAAOC,CAAAA,WAAP,qBAWA,QAASC,CAAAA,cAAT,CAAwBC,YAAxB,CAAsC,CACpC,MAAO,OAAMC,IAAN,CAAWD,YAAX,CAAP,CACD,CAcD,QAASE,CAAAA,YAAT,CAAsBF,YAAtB,CAAoC,CAClC,MAAO,qBAAoBC,IAApB,CAAyBD,YAAzB,CAAP,CACD,CAWD,QAASG,CAAAA,UAAT,CAAoBC,KAApB,CAA2B,CACzB,MAAOP,CAAAA,CAAC,CAACQ,MAAF,CACLD,KADK,CAEL,SAACE,MAAD,CAASC,KAAT,CAAgBC,GAAhB,CAAwB,CACtB,GAAIC,CAAAA,YAAY,CAAGH,MAAM,CAACI,cAA1B,CACA,GAAIX,cAAc,CAACS,GAAD,CAAlB,CAAyB,CACvBC,YAAY,CAAGH,MAAM,CAACK,aAAtB,CACD,CAFD,IAEO,IAAIT,YAAY,CAACM,GAAD,CAAhB,CAAuB,CAC5BC,YAAY,CAAGH,MAAM,CAACM,aAAtB,CACD,CACDH,YAAY,CAACD,GAAD,CAAZ,CAAoBD,KAApB,CACA,MAAOD,CAAAA,MAAP,CACD,CAXI,CAYL,CACEI,cAAc,CAAE,EADlB,CAEEC,aAAa,CAAE,EAFjB,CAGEC,aAAa,CAAE,EAHjB,CAZK,CAAP,CAkBD,CAyBD,MAAO,SAASC,CAAAA,qBAAT,CACLC,aADK,CAML,IAJAC,CAAAA,UAIA,2DAJa,EAIb,IAHAC,CAAAA,UAGA,2DAHa,EAGb,IAFAC,CAAAA,WAEA,2DAFc,EAEd,IADAC,CAAAA,UACA,2CAUA,GAAIC,CAAAA,WAAW,CAAGrB,WAAW,CAACkB,UAAD,CAAaC,WAAW,CAACH,aAAD,CAAxB,CAA7B,CACAC,UAAU,CAACK,OAAX,CAAmB,SAACC,EAAD,CAAKC,KAAL,CAAe,CAChCH,WAAW,CAAGrB,WAAW,CAACqB,WAAD,CAAcH,UAAU,IAAIK,EAAJ,CAAxB,CAAzB,CACD,CAFD,EAIAN,UAAU,CAACK,OAAX,CAAmB,SAACC,EAAD,CAAKC,KAAL,CAAe,CAChCH,WAAW,CAAGrB,WAAW,CACvBqB,WADuB,CAEvBF,WAAW,IAAIH,aAAJ,CAAoBO,EAApB,CAFY,CAAzB,CAID,CALD,EAmBA,GAAIE,CAAAA,aAAa,CAAGzB,WAAW,CAACqB,WAAD,CAAcF,WAAW,CAACH,aAAD,CAAzB,CAA/B,CAEAC,UAAU,CAACK,OAAX,CAAmB,SAACC,EAAD,CAAKC,KAAL,CAAe,CAChCC,aAAa,CAAGzB,WAAW,CAACyB,aAAD,CAAgBJ,WAAW,IAAIE,EAAJ,CAA3B,CAA3B,CACD,CAFD,EAIAN,UAAU,CAACK,OAAX,CAAmB,SAACC,EAAD,CAAKC,KAAL,CAAe,CAChCC,aAAa,CAAGzB,WAAW,CACzByB,aADyB,CAEzBN,WAAW,IAAIH,aAAJ,CAAoBO,EAApB,CAFc,CAA3B,CAID,CALD,EAOA,MAAOE,CAAAA,aAAP,CACD","sourcesContent":["import _ from \"lodash\";\nimport customMerge from \"./customMerge\";\n\n/**\n * Matches any style properties that represent component style variants.\n * Those styles can be applied to the component by using the styleName\n * prop. All style variant property names must start with a single '.'\n * character, e.g., '.variant'.\n *\n * @param propertyName The style property name.\n * @returns {boolean} True if the style property represents a component variant, false otherwise.\n */\nfunction isStyleVariant(propertyName) {\n  return /^\\./.test(propertyName);\n}\n\n/**\n * Matches any style properties that represent style rules that target the\n * component children. Those styles can have two formats, they can either\n * target the components by component name ('shoutem.ui.Text'), or by component\n * name and variant ('shoutem.ui.Text.line-through'). Beside specifying the\n * component name, those styles can also target any component by using the\n * '*' wildcard ('*', or '*.line-through'). The rule to identify those styles is\n * that they have to contain a '.' character in their name or be a '*'.\n *\n * @param propertyName The style property name.\n * @returns {boolean} True if the style property represents a child style, false otherwise.\n */\nfunction isChildStyle(propertyName) {\n  return /(^[^\\.].*\\.)|^\\*$/.test(propertyName);\n}\n\n/**\n * Splits the style into its parts:\n * component style - concrete style that needs to be applied to a component\n * style variants - variants that can be applied to a component by using styleName prop\n * children style - style rules that need to be propagated to component children\n *\n * @param style The style to split.\n * @returns {*} An object with the componentStyle, styleVariants, and childrenStyle keys.\n */\nfunction splitStyle(style) {\n  return _.reduce(\n    style,\n    (result, value, key) => {\n      let styleSection = result.componentStyle;\n      if (isStyleVariant(key)) {\n        styleSection = result.styleVariants;\n      } else if (isChildStyle(key)) {\n        styleSection = result.childrenStyle;\n      }\n      styleSection[key] = value;\n      return result;\n    },\n    {\n      componentStyle: {},\n      styleVariants: {},\n      childrenStyle: {}\n    }\n  );\n}\n\n/**\n * Resolves the final component style by merging all of the styles that can be\n * applied to a component in the proper order.\n *\n * This function extracts the applicable parts of the theme, parent and element\n * styles, and merges the styles that target the component, and component variants\n * with those styles to get the final style.\n *\n * The styles are merged in the following order, where the styles with the\n * higher index override the styles with the lower one:\n * 1. Theme component style\n * 2. Parent component style\n * 3. Theme style variants specified through styleName\n * 4. Parent style variants specified through styleName\n * 5. Element style passed through the style prop\n *\n * @param componentName The component name ('shoutem.ui.Text')\n * @param styleName Style names ('large rounded')\n * @param themeStyle The theme style that should include the theme and base component style\n * @param parentStyle The style rules inherited from the parent component\n * @param elementStyle The style passed through the style prop of the component\n * @returns {{componentStyle, childrenStyle}} The resolved component and children styles.\n */\nexport function resolveComponentStyle(\n  componentName,\n  styleNames = [],\n  themeStyle = {},\n  parentStyle = {},\n  themeCache\n) {\n  // const mergedStyle = _.merge({},\n  //   themeStyle,\n  //   parentStyle['*'],\n  //   parentStyle[componentName],\n  //   ..._.map(styleNames, (sn) => themeStyle[`.${sn}`]),\n  //   ..._.map(styleNames, (sn) => parentStyle[`*.${sn}`]),\n  //   ..._.map(styleNames, (sn) => parentStyle[`${componentName}.${sn}`])\n  // );\n\n  let mergedStyle = customMerge(themeStyle, parentStyle[componentName]);\n  styleNames.forEach((sn, index) => {\n    mergedStyle = customMerge(mergedStyle, themeStyle[`${sn}`]);\n  });\n\n  styleNames.forEach((sn, index) => {\n    mergedStyle = customMerge(\n      mergedStyle,\n      parentStyle[`${componentName}${sn}`]\n    );\n  });\n\n  // Phase 2: merge the component styles, this step is performed by using the\n  // style from phase 1, so that we are sure that the final style variants are\n  // applied to component style.\n  // const resolvedStyle = _.merge({},\n  //   mergedStyle,\n  //   parentStyle['*'],\n  //   parentStyle[componentName],\n  //   ..._.map(styleNames, (sn) => mergedStyle[`.${sn}`]),\n  //   ..._.map(styleNames, (sn) => parentStyle[`*.${sn}`]),\n  //   ..._.map(styleNames, (sn) => parentStyle[`${componentName}.${sn}`])\n  // );\n\n  let resolvedStyle = customMerge(mergedStyle, parentStyle[componentName]);\n\n  styleNames.forEach((sn, index) => {\n    resolvedStyle = customMerge(resolvedStyle, mergedStyle[`${sn}`]);\n  });\n\n  styleNames.forEach((sn, index) => {\n    resolvedStyle = customMerge(\n      resolvedStyle,\n      parentStyle[`${componentName}${sn}`]\n    );\n  });\n\n  return resolvedStyle;\n}\n"]},"metadata":{},"sourceType":"module"}